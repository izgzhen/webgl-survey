\section{Case Study: Threejs}\label{case-study-threejs}

\subsection{API samples}\label{api-samples}

\href{http://threejs.org/docs/}{Docs}

A example app, its workflow:

\begin{itemize}
\tightlist
\item
  initialize \texttt{scene}, \texttt{camera} and \texttt{renderer}.
\item
  Create mesh object from geometry and material add them to the scene
\item
  Render based on scene and camera frame by frame
\end{itemize}

\begin{verbatim}
<html>
    <head>
        <title>My first Three.js app</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            var cube = new THREE.Mesh( geometry, material );
            scene.add( cube );

            camera.position.z = 5;

            var render = function () {
                requestAnimationFrame( render );

                cube.rotation.x += 0.1;
                cube.rotation.y += 0.1;

                renderer.render(scene, camera);
            };

            render();
        </script>
    </body>
</html>
\end{verbatim}

\subsection{Library structure}\label{library-structure}

\begin{quote}
The current three.js implementation is too huge -- I will take its early
release \texttt{three.js-r16} as a preliminary analysis object.
\end{quote}

The \texttt{src} contains

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  cameras: set up the perspective matrix etc. based on camera paramters
\item
  core

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Color: convert hexadecimal code into internal representation and
    better format
  \item
    Face3/Face4: Wrap end-points and normal vector into a high-level
    structure \texttt{Face}
  \item
    Geometry: A geometry is a set of vertices and faces connecting the
    vertices, this function computes the normals of each face (which
    might be useful in texture or fragment shader?)
  \item
    Vector(2, 3, 4)/Matrix4: Basically same as \texttt{gl-matrix}
  \item
    Vertex: Wrapper over position and normal (normal?)
  \item
    UV: (u, v) coordinate (NOTE: UV mapping is a process of flattening
    the 3-dimensional object)
  \item
    Rectangle: Again, a geometry wrapper
  \end{enumerate}
\item
  materials: Wrap the attribute values of different materials
\item
  objects: Simple wrappers of \texttt{Line}, \texttt{Mesh},
  \texttt{Object3D} etc.
\item
  renderers

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    \texttt{renderables}: \texttt{RendererableFace(3,4)},
    \texttt{RenderableLine}, \texttt{RenderableParticle} etc., looks
    like another set of wrappers
  \item
    \texttt{CanvasRenderer}: In construction, context is get from
    created \texttt{canvas} element; A lot of other vectors and
    rectangle are created as well. The functions provided include
    \texttt{setSize}, \texttt{clear}, \texttt{render},
    \texttt{drawTexturedTriangle} and \texttt{expand}. However, this is
    only a 2d canvas.
  \item
    \texttt{Renderer}: Its data includes pools of face3, face4, line and
    particles, as well as a vector4 and a matrix4. The exposed
    interfaces include a \texttt{renderList} and method
    \texttt{project}. I suppose that this will do some transformation
    (like projection), and push the things left to render into
    \texttt{renderList}
  \item
    \texttt{SVGRenderer}: Similar to \texttt{CanvasRenderer}
  \item
    \texttt{WebGLRenderer}: Similar to \texttt{CanvasRenderer}, we have
    some basic bootstrapping and after that, we call \texttt{initGL} and
    \texttt{initProgram}; The utilities provided include
    \texttt{setSize}, \texttt{clear} \texttt{render},
    \texttt{getShader}; There are also internal functions
    \texttt{getShader} and \texttt{matrix2Array}.

    \begin{itemize}
    \tightlist
    \item
      \texttt{initGL}: It will try to get context, and will throw in
      case of incompatibility. If context is ready, it will do
      \texttt{clearColor}, \texttt{clearDepth} and other config and
      setups.
    \item
      \texttt{initProgram}: Two shaders, fragment and vertex shaders are
      hard-coded here. With attached shaders, it link and use the
      program. Finally, it will set other attributes related.
    \item
      \texttt{clear}: Clear the \texttt{COLOR\_BUFFER\_BIT} and
      \texttt{DEPTH\_BUFFER\_BIT} bits.
    \item
      \texttt{render}: Given a \texttt{scene} and a \texttt{camera}, it
      will render the mesh object in \texttt{scene} one by one. Every
      mesh object will have its vertex buffer. The related data also
      contains faces and color. For every face, its three vertices will
      be push into the array, same for color. With buffers ready, it
      will create, bind and fill in one by one with
      \texttt{createBuffer}, \texttt{bindBuffer} and
      \texttt{bufferData}. After that, the view matrix and projection
      matrix is set. Next, the material of object is rendered as well.
      The color of face are pushed into the buffer, bind and filled in.
      Finally, we will call \texttt{drawElements}.
    \item
      \texttt{getShader}: It is basically wrapping around
      \texttt{createShader}, \texttt{shaderSource},
      \texttt{compileShader}.
    \end{itemize}
  \end{enumerate}
\item
  scenes: Wrapper of an array of objects
\end{enumerate}
